using System;
using System.Collections;
using System.Collections.Generic ;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Security.Cryptography;
namespace PKCS1Signature
{
    /**
     * The RSA-PKCS1-V1.5 signature scheme is a digital signature scheme with
     * appendix (SSA) combining the RSA algorithm with the EMSA-PKCS1-v1_5 encoding method.
     */
    class RSAPKCS1V1_5Signature
    {
        /** The public key to use when verifying signatures. */
        protected RSAKey publicKey;

        /** The private key to use when generating signatures (signing). */
        protected RSAKey privateKey;

        private static byte[] SHA256_PREFIX = {
            (byte) 0x30, (byte) 0x31, (byte) 0x30, (byte) 0x0d, (byte) 0x06,
            (byte) 0x09, (byte) 0x60, (byte) 0x86, (byte) 0x48, (byte) 0x01,
            (byte) 0x65, (byte) 0x03, (byte) 0x04, (byte) 0x02, (byte) 0x01,
            (byte) 0x05, (byte) 0x00, (byte) 0x04, (byte) 0x20
        };

        /**
         * Converts a multi-precision integer (MPI) s into an
         * octet sequence of length k.
         * 
         * @param s the multi-precision integer to convert.
         * @param k the length of the output.
         * @return the result of the transform.
         * @exception ArgumentException if the length in octets of meaningful
         *              bytes of s is greater than k.
         */
        public static byte[] I2OSP(BigInteger s, int k)
        {
            byte[] result = s.ToByteArray().Reverse().ToArray();
            if (result.Length < k)
            {
                byte[] newResult = new byte[k];
                Array.Copy(result, 0, newResult, k - result.Length, result.Length);
                result = newResult.Reverse().ToArray();
            }

            return result;
        }

        /**
         * Converts an octet sequence os into a multi-precision integer (MPI).
         * 
         * @param s the multi-precision integer to convert.
         * @param k the length of the output.
         * @return the result of the transform.
         * @exception ArgumentException if the length in octets of meaningful
         *              bytes of s is greater than k.
         */
        public static BigInteger OS2IP(byte[] os)
        {
            return new BigInteger(os.Reverse().ToArray());
        }

        /**
         * An implementation of the RSASP method: Assuming that the designated
         * RSA private key is a valid one, this method computes a signature
         * representative for a designated message representative signed
         * by the holder of the designated RSA private key.
         * 
         * @param K the RSA private key.
         * @param m the message representative: an integer between
         *          0 and n - 1, where n
         *          is the RSA modulus.
         * @return the signature representative, an integer between
         *         0 and n - 1, where n
         *         is the RSA modulus.
         */
        public static BigInteger RSASP1(RSAKey K, BigInteger m)
        {
            // 1. If the representative c is not between 0 and n - 1, output
            // "representative out of range" and stop.
            BigInteger n = K.getModulus();
            if (m.CompareTo(BigInteger.Zero) < 0 || m.CompareTo(n - BigInteger.One) > 0)
                throw new ArgumentException();
            // 2. The representative m is computed as follows.
            BigInteger result;
            // a. If the first form (n, d) of K is used, let m = c^d mod n.
            BigInteger d = K.getExponent();
            result = BigInteger.ModPow(m, d, n);

            // 3. Output m
            return result;
        }

        /**
         * An implementation of the RSAVP method: Assuming that the designated
         * RSA public key is a valid one, this method computes a message
         * representative for the designated signature representative
         * generated by an RSA private key, for a message intended for the holder of
         * the designated RSA public key.
         * 
         * @param K the RSA public key.
         * @param s the signature representative, an integer between
         *          0 and n - 1, where n is the RSA modulus.
         * @return a message representative: an integer between 0
         *         and n - 1, where n is the RSA modulus.
         */
        public static BigInteger RSAVP1(RSAKey K, BigInteger s)
        {
            // 1. If the representative m is not between 0 and n - 1, output
            // "representative out of range" and stop.
            BigInteger n = K.getModulus();
            if (s.CompareTo(BigInteger.Zero) < 0 || s.CompareTo(n - BigInteger.One) > 0)
                throw new ArgumentException();
            // 2. Let c = m^e mod n.
            BigInteger e = K.getExponent();
            BigInteger result = BigInteger.ModPow(s, e, n); ;
            // 3. Output c.
            return result;
        }

        /**
         * Signature generation operation.
         * 
         * @param K signer's RSA private key
         * @param M message to be signed, an octet string
         * @return signature, an octet string of length k, where k is the length in octets of the RSA modulus n
         */
        public static byte[] sign(RSAKey K, String M)
        {
            // 1. EMSA-PKCS1-v1_5 encoding: Apply the EMSA-PKCS1-v1_5 encoding
            // operation (Section 9.2) to the message M to produce an encoded
            // message EM of length k octets:
            //
            // EM = EMSA-PKCS1-V1_5-ENCODE (M, k).
            //
            // If the encoding operation outputs "message too long," output
            // "message too long" and stop. If the encoding operation outputs
            // "intended encoded message length too short," output "RSA modulus
            // too short" and stop.
            int modBits = bitLength(K.getModulus());
            int k = (modBits + 7) / 8;
            byte[] EM = EMSA_PKCS1_V1_5_ENCODE(M, k);
            BigInteger test = OS2IP(EM);
            // 2. RSA signature:
            // a. Convert the encoded message EM to an integer message epresentative
            // m (see Section 4.2): m = OS2IP (EM).
            BigInteger m = OS2IP(EM);
            // b. Apply the RSASP1 signature primitive (Section 5.2.1) to the RSA
            // private key K and the message representative m to produce an
            // integer signature representative s: s = RSASP1 (K, m).
            BigInteger s = RSASP1(K, m);
            // c. Convert the signature representative s to a signature S of length
            // k octets (see Section 4.1): S = I2OSP (s, k).
            // 3. Output the signature S.
            return I2OSP(s, k);
        }
    
        /**
         * Signature verification operation.
         * 
         *  @param K signer's RSA public key
         *  @param M message whose signature is to be verified, an octet string
         *  @param S signature to be verified, an octet string of length k, where
         *           k is the length in octets of the RSA modulus n
         *  
         *  @return true/false - "valid signature"/"invalid signature"
         */
        public static bool verify(RSAKey K, String M, byte[] S)
        {
            // 1. Length checking: If the length of the signature S is not k octets,
            // output "invalid signature" and stop.
            int modBits = bitLength(K.getModulus());
            int k = (modBits + 7) / 8;
            if (S.Length != k)
                return false;
            // 2. RSA verification:
            // a. Convert the signature S to an integer signature representative
            // s (see Section 4.2): s = OS2IP (S).
            BigInteger s = OS2IP(S);
            // b. Apply the RSAVP1 verification primitive (Section 5.2.2) to the
            // RSA public key (n, e) and the signature representative s to
            // produce an integer message representative m:
            // m = RSAVP1 ((n, e), s).
            // If RSAVP1 outputs "signature representative out of range,"
            // output "invalid signature" and stop.
            BigInteger m;
            try
            {
                m = RSAVP1(K, s);
            }
            catch (ArgumentException x)
            {
                return false;
            }
            // c. Convert the message representative m to an encoded message EM
            // of length k octets (see Section 4.1): EM = I2OSP (m, k).
            // If I2OSP outputs "integer too large," output "invalid signature"
            // and stop.
            byte[] EM;
            try
            {
                EM = I2OSP(m, k);
            }
            catch (ArgumentException x)
            {
                return false;
            }
            // 3. EMSA-PKCS1-v1_5 encoding: Apply the EMSA-PKCS1-v1_5 encoding
            // operation (Section 9.2) to the message M to produce a second
            // encoded message EM' of length k octets:
            // EM' = EMSA-PKCS1-V1_5-ENCODE (M, k).
            // If the encoding operation outputs "message too long," output
            // "message too long" and stop. If the encoding operation outputs
            // "intended encoded message length too short," output "RSA modulus
            // too short" and stop.
            byte[] EMp = EMSA_PKCS1_V1_5_ENCODE(M, k).Reverse().ToArray();
            // 4. Compare the encoded message EM and the second encoded message EM'.
            // If they are the same, output "valid signature"; otherwise, output
            // "invalid signature."
            for (int i = 0; i < EM.Length; i++)
            {
                if (EM[i] != EMp[i])
                {
                    return false;
                }
            }
                return true;
        }
        public static bool verify(RSAKey K, String M, BigInteger S)
        {
            int modBits = bitLength(S);
            int k = (modBits + 7) / 8;
            return verify(K, M, I2OSP(S, k));
        }

        /**
         * Frames the hash of a message, along with an ID of the hash function in
         * a DER sequence according to the specifications of EMSA-PKCS1-V1.5 as
         * described in RFC-3447.
         *
         * @param M message to be encoded
         * @param emLen intended length in octets of the encoded message, at least
         *  tLen + 11, where tLen is the octet length of the DER
         *  encoding T of a certain value computed during the encoding operation
         *
         * @return EM encoded message, an octet string of length emLen
         */
        public static byte[] EMSA_PKCS1_V1_5_ENCODE(String M, int emLen)
        {
            // 1. Apply the hash function to the message M to produce a hash value
            //    H: H = Hash(M).
            //    If the hash function outputs "message too long," output "message
            //    too long" and stop.

            byte[] mBytes = new byte[M.Length * sizeof(char)];
            System.Buffer.BlockCopy(M.ToCharArray(), 0, mBytes, 0, mBytes.Length);
            SHA256Managed hash = new SHA256Managed();
            byte[] mHash = hash.ComputeHash(mBytes, 0, mBytes.Length);

            // 2. Encode the algorithm ID for the hash function and the hash value
            //    into an ASN.1 value of type DigestInfo (see Appendix A.2.4) with
            //    the Distinguished Encoding Rules (DER), where the type DigestInfo
            //    has the syntax
            //       DigestInfo ::= SEQUENCE {
            //          digestAlgorithm AlgorithmIdentifier,
            //          digest OCTET STRING
            //       }
            //   The first field identifies the hash function and the second contains
            //   the hash value.  Let T be the DER encoding of the DigestInfo value
            //   (see the notes below) and let tLen be the length in octets of T.
            MemoryStream memStream = new MemoryStream();
            memStream.Write(SHA256_PREFIX, 0, SHA256_PREFIX.Length);
            memStream.Write(mHash, 0, mHash.Length);
            byte[] T = memStream.ToArray();
            int tLen = T.Length;
            // 3. If emLen < tLen + 11, output "intended encoded message length too
            //    short" and stop.
            if (emLen < tLen + 11)
                throw new ArgumentException("emLen too short");
            // 4. Generate an octet string PS consisting of emLen - tLen - 3 octets
            //    with hexadecimal value 0xff.  The length of PS will be at least 8
            //    octets.
            byte[] PS = new byte[emLen - tLen - 3];
            for (int i = 0; i < PS.Length; i++)
                PS[i] = (byte)0xFF;
            // 5. Concatenate PS, the DER encoding T, and other padding to form the
            //    encoded message EM as: EM = 0x00 || 0x01 || PS || 0x00 || T.
            memStream.SetLength(0);
            memStream.WriteByte(0x00);
            memStream.WriteByte(0x01);
            memStream.Write(PS, 0, PS.Length);
            memStream.WriteByte(0x00);
            memStream.Write(T, 0, tLen);
            byte[] result = memStream.ToArray();
            memStream.Close();
            
            // 6. Output EM.
            return result;
        }

        /**
         * Counts bit length of BigInteger.
         */
        static int bitLength(BigInteger x)
        {
            int bitLength = 0;
            do
            {
                bitLength++;
                x /= 2;
            } while (x != 0);
            return bitLength;
        }
    }

    /**
         * RSA key class.
         */
    class RSAKey
    {
        BigInteger n; // modulus is the RSA modulus n.
        BigInteger e; // publicExponent is the RSA public exponent e.

        public RSAKey(BigInteger n, BigInteger e)
        {
            this.n = n;
            this.e = e;
        }

        public BigInteger getModulus()
        {
            return n;
        }
        public BigInteger getExponent()
        {
            return e;
        }

    }
}
